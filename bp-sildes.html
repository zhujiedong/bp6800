<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>使用 BP 程序进行特定的光合测量</title>
    <meta charset="utf-8" />
    <meta name="author" content="祝介东" />
    <link rel="stylesheet" href="zh-CN.css" type="text/css" />
    <link rel="stylesheet" href="extra-rutgers.css" type="text/css" />
    <link rel="stylesheet" href="animate-min.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# 使用 BP 程序进行特定的光合测量
## 以实际应用为例
### 祝介东
### 北京力高泰科技有限公司 技术部
### 2020-04-26 修改

---

background-image: url(https://s2.ax1x.com/2020/03/09/8S2l7T.png)

background-size: cover

class: left, middle, animated, fadeIn

# 主要内容

.pull-left[
# 1. 什么是 BP

# 2. STEP 的组成

# 3. STEP 组分介绍
]

.pull-right[
# 4. BP 已有的库

# 5. BP 界面介绍

# 6. BP 程序示例
]


---
class: animated, fadeIn, center, middle, inverse

# .large[BP 程序介绍]
---
class: animated, fadeIn

# 后台程序 (BP)

#### .tomato.large.bold[BP 的定义：]

BP（Background Program） 指的是一系列步骤的集合，能够在 6800 后台运行以完成各种任务。

#### .tomato.large.bold[什么是步骤（step）:]

本质上是 Python 中一个未经执行的字符串的表达式（expression），当其被调用时，表达式被 Python 的 `eval()` 或 `exec()` 执行。多数情况下，实际上被执行的是一个 .large.purple.bold[步骤 (STEP)] 的集合，以实现更复杂的目的，这个步骤的集合本质上是 Python 中的列表（list）。

也就是说 Background Program .large.purple.bold[本质上是 Python 程序]，而 LI-6800 就像是一台安装了 BSD 的电脑，来执行这些 BP。

---

class: animated, fadeIn, center, middle, inverse

# .large[BP 相关的知识]
---
class: animated, fadeIn

# 从 Python 的角度理解 BP

.tomato.bold[BP 可以无需 Python 基础使用，但了解相关的背景有助于加深对其理解和使用。]
- **list:** 列表，Python 中最万能的数据类型，写法是在 ** [] ** 内的，使用逗号分隔的值（values 或 items）。可以通过索引（index）来调用单个元素或多个元素，**Python 索引是以 0 为起始，也就是第一个元素应为 [0]**，它有个最大的特点就是值的类型不必相同,例如：

 ```python
list1 = ["LI-6800", 21, 0.08, "BP"]
 ```

- **STEP：**本质上是 list，Python 内并无此名词，是 BP 中 定义的一个由字符组成的列表，因为这个 list 的内容要被 `eval()` 或 `exec()` 执行，所以这些字符的写法要符合 bpdefs 模块的要求。例如列表中常见的几种赋值 ASSGIN 的写法为：

 ```python
steps = [ASSIGN("Fs", dd=DataDict('Flow_s','Status')),
ASSIGN("isOpen", exp="Fs &lt; 10"),
ASSIGN("tleafok",	exp="lambda t: 1 if (t != 0) and (t &gt; -20) and (t &lt; 60) else 0"),
ASSIGN("numTCs", exp="tleafok(data['Tleaf']) + tleafok(data['Tleaf2'])")
]
 ```
---
class: animated, fadeIn

# 从 Python 的角度理解 BP

- **eval:** STEP 中的内容是字符串，字符串是无法执行的，需要转为表达式（可以赋给变量的任意的对象），并且 eval 也只能接受单个表达式，并返回表达式的值。

- **exec：** 与 eval 类似，但不返回表达式的值，并能接受动态创建的语句或程序。在 BP 中，exec 实际由 EXEC 来替代。

.large.bold.purple[使用 BP 需要首先明白两点：]

1. 运行 BP 并不是直接运行 .py 文件，而是 .py 文件首先被编译（eval()）以获取 STEPS 列表，**然后 BP 使用这些 STEPS 作为数据来运行**。

2. 我们创建的变量是**存在于列表中**，变量和表达式在这一阶段必须**以字符的形式存在**。例如上一页中演示的 ASSIGN 第一个参数，实际应为一个变量（该阶段还不是），此时必须加引号将其作为字符存在（否则因为环境中无此变量，`eval() `就会报错）。换言之，我们写的代码必须发送到 eval() 或 exec() 两次：、
  1. 创建 STEP，也就是创建字符组成的 list，被 eval() 或 exec() 处理后变为 STEP 的数据，或者说是转变为表达式或语句的存在。
  
  2. BP 使用上面的 STEP 数据来构建 BP，然后作为 python 程序来运行。


???

exec is for statement and does not return anything. eval is for expression and returns value of expression.
expression means "something" while statement means "do something".

---
class: animated, fadeIn, center, middle, inverse

# .large[BP 与 AutoProgram 的差别]

---
class: animated, fadeIn
# BP 与 AutoProgram？

在 LI-6800 上内置了功能全面的 AutoProgram，为什么又有了 BP 呢，二者有什么不同？

### 二者差异主要体现在：

- BP 能实现所有的 AutoProgram，但 AutoProgram 对新手友好（无需编程，直接使用）。

- AutoProgram 每次只能执行一个，但理论上讲 BP 可以同时执行任何个数。

- BP 能够实现 AutoProgram 不能实现的功能，即可以在规则内定制自己所需要的程序。
---

class: animated, fadeIn, center, middle, inverse

# .large[STEP 介绍]
---
class: animated, fadeIn

# STEPS 的基本组成

## BP 的执行需要：

### 1. 编写 STEPS

### 2. STEPS 将被 eval() 或 exec()，生成一个参数化的 list 的过程

### 3. 系统安装的 python （使用 Python 3） 使用 BP 将 STEPS 作为数据运行的过程

.large.tomato[其中，我们需要做的工作仅仅是 STEPS 的编写过程。因此掌握 STEPS 的各个命令是写好 BP 的前提，我们先了解一下 BP 的命令。]
---
# 语句（statement）
&lt;iframe src="./statement.html" width=80% height=80% frameborder=0  allowtransparency="true"&gt; &lt;/iframe&gt;

---
# 流控制（program flow control）
&lt;iframe src="./flow-control.html" width=80% height=80% frameborder=0 allowtransparency="true"&gt; &lt;/iframe&gt;


---
class: animated, fadeIn, center, middle, inverse

# .large[STEP 已有的库（library）]

---
class: animated, fadeIn

# 已有的库

&lt;iframe src="./defines.html" width=80% height=80% frameborder=0 allowtransparency="true"&gt; &lt;/iframe&gt;

---
class: animated, fadeIn

# 已有的库

&lt;iframe src="./groups.html" width=80% height=80% frameborder=0 allowtransparency="true"&gt; &lt;/iframe&gt;

---
class: animated, fadeIn, center, middle, inverse

# .large[BP 使用界面（联机演示）]

---

class: animated, fadeIn, center, middle, inverse

# .large[BP 程序示例]

---
class: animated, fadeIn
# 示例1： 改变环境控制和记录时间的测量

### .tomato[以下时间的设置仅为演示所需，可任意更改]

### 1. 设置 `\(CO_2R\)` 的值为 0，记录 2 min，记录间隔  1 min。

### 2. 设置 `\(CO_2R\)` 的值为 400，记录 1 min，记录间隔  30 s。

### 3. 设置 `\(CO_2R\)` 的值为 0，记录 1 min，记录间隔  30 s。

---
class: animated, fadeIn
# 方法 1

### 1. 设置 `\(CO_2R\)` 浓度
### 2. 根据需要是否设置等待浓度稳定的时间
### 3. 利用 LOOP 的循环持续时间功能来设置记录的时间和间隔

### 最后将上述步骤重复 n 次，来完成控制。

---

class: animated, fadeIn
# 方法 2

### 1. 设置 `\(CO_2R\)` 浓度
### 2. 根据需要是否设置等待浓度稳定的时间
### 3. 调用 DEFINEs 的 autolog 来自动记录一定时间的数据

### 最后将上述步骤重复 n 次，来完成控制。

### 注：同方法1没有本质的区别，但胜在减少了编辑的时间或者可以控制某一步不进行。
---
class: animated, fadeIn
# 方法 1 的关键 STEP：
```python
PROPERTIES(verbose="True",pause="False"),
LOG(open="\"/home/licor/logs/zjd/test\"",app=False),
SETCONTROL("CO2_r","0","float"),
LOOP(dur="1",
	units="Minutes",
	steps=()
		WAIT(dur="10",units="Seconds"),
		LOG(),
	)
),
LOG(close=0),
```
---
class: animated, fadeIn
# STEPs 的解释
- 在日志显示信息
  ```python
  PROPERTIES(verbose="True",pause="False")
  ```

- 在 logs 文件夹下的 zjd 文件夹打开一个 test 文件，不追加
  ```python
LOG(open="\"/home/licor/logs/zjd/test\"",app=False)
  ```
  
- 控制二氧化碳浓度
  ```python
SETCONTROL("CO2_r","0","float")
  ```
- 开始一个循环，时间持续 1 min 中，每 10 s 记录一个数据
  ```python
LOOP(dur="1",	units="Minutes",	steps=() WAIT(dur="10",units="Seconds"),LOG(),
 	)
 ```
-  LOG 有关闭数据文件的功能

  ```python
LOG(close=0)
  ```

---
class: animated, fadeIn
# 方法 2 STEPs 的解释
```python
PROPERTIES(verbose="True",pause="False"),
LOG(open="\"/home/licor/logs/zjd/test\"",app=False),
SETCONTROL("CO2_r","0","float"),
CALL("AutoLog",
	['0.5', '10']),
SETCONTROL("CO2_r","300","float"),
CALL("AutoLog",
	['0.5', '10']),
SETCONTROL("CO2_r","300","float"),
CALL("AutoLog",
	['0.5', '10']),
LOG(close=0),
```

- 该方法直接利用 DEFINEs 库的 AutoLog 来记录数据，避免了手动插入 LOOP。

- 在 DEFINEs 库中的文件可以直接调用，无需放在一个 py 文件内

- 调用的方法是 CALL
---
class: animated, fadeIn, center, middle, inverse

# .large[示例 1 的演示]
---

class: animated, fadeIn
# 示例2

.large[例如我们需要记录一个叶片在光强在突然变化后的数据，我们期望能以变化的时间间隔记录数据，在最初的时间，光合速率剧烈变化，我们希望能以很短的时间间隔记录数据，然后光合数据变化减缓，变化需要时间的气孔导度等数据也不需要快速记录，这样我们再使用比较长的时间间隔来记录。

一直以非常高的频率计数不是不行，只是增加了我们后续处理数据的量。


- 控制光强的变化为 1500，50， 1500

- 使用逻辑方程（即著名的 S 型曲线）来控制记录的间隔，初期间隔短，中期时间间隔快速增加，后期几乎不变，记录 15 mins 中。

]
---
class: animated, fadeIn
# 演示前详解


.pull-left[### 构造函数

&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;

我们使用典型的逻辑回归方程构造记录间隔的函数：

`$$f(t)=\frac{30}{1+50e^{-0.03t}}$$`

]

.pull-right[
&lt;img src="./img/logistic.png" width="987" style="display: block; margin: auto 0 auto auto;" /&gt;
]

---
class: animated, fadeIn
# 几个关键的 STEPS 设置

```python
ASSIGN("logint",
	exp="lambda x: 30/(1+50*math.exp(-0.03*x))+0"),
ASSIGN("test",
	exp="lambda x: x if x &gt;= 1 else 0"),
LOOP(list="1500,50,1500",
	var="x",
	steps=(
		SETCONTROL("Qin","x","float"),
		LOOP(dur="15",
			units="Minutes",
			var="t",
			mininc="test(logint(t))",
			steps=(
				LOG(avg="Off",
					match="Off",
					flr="0: Nothing"),
			)
		),
	)
)
```
---
class: animated, fadeIn
# 几个 STEPS 中的知识点

- `lambda` Python 的匿名函数。

- `ASSIGN`  将表达式赋给变量。`ASSIGN('logint', exp ="lambda x:30/(1+50*math.exp(-0.03*x))")`，执行时会转换为： `logint = lambda x:30/(1+50*math.exp(-0.03*x))`，即记录时间间隔的变量为 logint。

- `math.exp` Python `math` 库中的自然常数。

- `LOOP`
  - 光强的控制相当于 Python 的 `for` 循环，`for x in [1500, 50, 1500]` 设置 `Qin = x`
  - 第二个 LOOP 其实也是 `for` 循环，`var `定义的 t 指从循环开始到现在的时间，`mininc` 是这个 LOOP 一个循环最小的等待时间，0 为等待 6800 有新数据记录。利用该参数和下面的写法实现最小等待 1 s 计数。
  ```python
ASSIGN("test", exp="lambda x: x if x &gt;= 1 else 0")
test(logint(t))
  ```
  
- LOG 项为记录数据，这里参数的意思是不取平均值，不匹配，不记录荧光。
  
---

class: animated, fadeIn, center, middle, inverse

# .large[示例 2 的演示]

---
class: animated, fadeIn
# 示例3：时间序列的重现

&lt;br /&gt;
&lt;br /&gt;
在实际应用中，我们可能需要重现一个时间序列的变化，这十分有用，例如我们通过记录一段时间内林下光斑的变化，然后利用 LI-6800 重现这个时间段内的变化，来进行光合参数的测量。

&lt;br /&gt;
&lt;br /&gt;
1. 记录一段时间环境的光强变化，并将时间和对应的光强存储到文件。

2. 运行另一个 BP，将上面的数据文件读取后，按照文件的光强记录一段时间的光强变化。
---
class: animated, fadeIn
# 关键的 STEPS

```python
ASSIGN("f",
	exp="open('/home/licor/logs/light_series.txt','w')"),
ASSIGN("q",
	dd=DataDict('PPFD_out','Meas'),
	track=True),
EXEC(0,source="print(\"Time,Light\",file=f)"),
LOOP(dur="1",
	units="Hours",
	mininc="2",
	steps=(
		ASSIGN("hhmmss",
			exp="datetime.now().strftime(\"%H:%M:%S\")"),
		ASSIGN("line",
			exp="'{0},{1}'.format(hhmmss,q)"),
		EXEC(0,source="print(line,file=f)"),
	)
),
EXEC(0,source="f.close()")
```
---
class: animated, fadeIn

# 几个 STEP 的解释
- 打开（新建）一个名为 light_series.txt 的文件，并对其进行写入操作
 ```python
 open('/home/licor/logs/light_series.txt','w')"
 ```
- 执行一个 python 语句，将其 Time 和 Light 作为表头存储到打开的文件中
 ```python
 EXEC(0,source="print(\"Time,Light\",file=f)")
 ```

- 利用 `datetime.now` 输出时间，并将其输出格式定义为 ISO 格式
 ```python
 "datetime.now().strftime(\"%H:%M:%S\")"
 ```
- 将时间和光强利用 format 格式化为逗号分隔符 
 ```python
'{0},{1}'.format(hhmmss,q)
 ```

---
class: animated, fadeIn
# 关键的 STEPS 及解释

```python
LOOP(file="\"/home/licor/logs/light_series.txt\"",
	parse=True,
	delim="Comma",
	skip="1",
	var="q",
	mininc="2",
	steps=(
		# Set a control: SETCONTROL('target', 'value', 'eval' [,opt_target=''])
		SETCONTROL("Qin","q[1]","float"),
	)
)
```

- LOOP 可以直接读取文件
- delim 指定分隔符
- mininc 每个光强的持续时间是 2 s

---
class: animated, fadeIn, center, middle, inverse

# .large[示例 3 的演示]

---
class: animated, fadeIn

# 示例4：不同 `\(CO_2\)` 浓度的光响应曲线

我们要做不同 `\(CO_2\)` 浓度下的光响应曲线，有几个问题：

- 能够根据物种定义不同的光强梯度

- 能够根据需要定义不同的  `\(CO_2\)` 的浓度

- 能够根据需要定义不同的最大最小等待时间，例如按照正常的情况，我们第一个点无需等待太久，因为我们要在最高光强下等待其稳定才开始测量，但如果考虑到了 `\(CO_2\)`  需要变化，我们第一个点则需要设置的等待时间较长，第二个点，第三个点反而是因为一直处于饱和光强下，等待时间可适当降低。

---
class: animated, fadeIn
# 方法1： 关键的 STEP
```python
TABLE("outer_table",
	[('CO2_r', [300, 400, 500, 600])]),
TABLE("inner_table",
	[('Qin', [1500, 1250, 1000, 750, 500, 250, 100]),
		('minWait', [300, 60, '', '', '', '', ''], {'format': ['f', 1, 2], 'units': 'secs'}),
		('maxWait', [500, 120, '', '', '', '', ''], {'format': ['f', 1, 2], 'units': secs'}),
		]),
LOOP(list="outer_table",
	var="outer_index",
	steps=(
		LOG(open="\"/home/licor/logs/co2_\"+str(outer_index)",app=False),
		LOG(rem="'automatic file'"),
		LOOP(list="inner_table",
			var="inner_index",
			steps=(
				WAIT(min="minWait",max="maxWait",early="False"),
				LOG(avg="On"),
			)
		)
```
---
class: animated, fadeIn
# 关键 STEP 详解
```python
TABLE("outer_table",
	[('CO2_r', [300, 400, 500, 600])]),
TABLE("inner_table",
	[('Qin', [1500, 1250, 1000, 750, 500, 250, 100]),
		('minWait', [300, 60, '', '', '', '', ''], {'format': ['f', 1, 2], 'units': 'secs'}),
		('maxWait', [500, 120, '', '', '', '', ''], {'format': ['f', 1, 2], 'units': secs'}),
		])
```
- TABLE 是可以作为 LOOP 的 list 列表来运行的，因此比那些一个 TABLE 后，可以使用 LOOP 来遍历其中的所有元素。

- 第一个变量为 TABLE 的名字，方便后面 LOOP 调用。

- 紧随其后的我们需要设置的为我们期望的控制项

- .red[此处应演示添加 dialog 修改数值的方法，待测试，待补充]

---
class: animated, fadeIn

# 关键 STEP 详解

```python
LOG(open="\"/home/licor/logs/co2_\"+str(outer_index)",app=False),
WAIT(min="minWait",max="maxWait",early="False")
```
- 为方便后续数据处理，将记录文件命名为 co2_+浓度的格式

- 利用 WAIT 实现等待稳定后匹配，此处关闭了 early match 功能

---
class: animated, fadeIn
# 方法2： 关键的 STEPs

```python
EXEC(0,file="/home/licor/resources/lib/list_utility.py"),
ASSIGN("q",
	exp="linearList(1500,50,8)"),
ASSIGN("minWait",
	exp="60"),
ASSIGN("firstWait",
	exp="300"),
LOOP(list="400,300,200,100",
	var="co2",
	steps=(
		SETCONTROL("CO2_s","co2","float"),
		LOG(open="\"/home/licor/logs/co2_\"+str(co2)",app=False),
		LOG(rem="'automatic file'"),
		LOOP(count="len(q)",
			var="i",
			steps=(
				SETCONTROL("Qin","q[i]","float"),
				ASSIGN("w",
					exp="firstWait if i==0 else minWait"),
				WAIT(min="w",max="2*w",early="False"),
				LOG(avg="On"),
			)
		)
```

---
class: animated, fadeIn

# 关键 STEP 详解
```python
EXEC(0,file="/home/licor/resources/lib/list_utility.py")
linearList(1500,50,8)
```
-  调用 list_utility 的 linearList 生成光强梯度。.red[应添加两个或三个来适当变化梯度，待测试，待补充]

```python
LOOP(count="len(q)",
			var="i",
			steps=(
				SETCONTROL("Qin","q[i]","float"),
				ASSIGN("w",
					exp="firstWait if i==0 else minWait"),
				WAIT(min="w",max="2*w",early="False"),
```
- 如果是第一个设置的光强梯度，那么等待的最小时间为 firstWait。也就是 300 s，否则为最小等待时间， 最大等待时间为最小等待时间的 2 倍。

---
class: animated, fadeIn, center, middle, inverse

# .large[示例 4 的演示]

---
class: animated, fadeIn

# 示例5：模拟多云天气的可变光的测量

&lt;img src="./img/cloud.png" width="832" /&gt;
- 控制稳定的 VPD 和叶温
- 设定 400 ppm 的 `\(CO_2\)` 和 1200 的光强对叶片进行诱导
- 设置低光 50 持续 30 mins，高光 1200 持续 10 mins 的变化
- 变化分别在 `\(CO_2\)` 为 50， 100， 200， 300， 400， 500， 600， 800， 1000 下进行

---
class: animated, fadeIn
# 推荐方法：

- 定义一个 subroutine，用于自动计数和控制光强和 `\(CO_2\)` 浓度。

- 使用 Call 反复调用，来修改浓度和光强的变化

- 在开始变化之前的诱导时，利用 WAIT 等待稳定，然后匹配

- 整个测量过程中控温，因为 range match 的存在，无需匹配
---
# 关键的 STEP
```python
WAIT(min="60",max="60*15",early="False"),
CALL("var_cr_qin", ['50', '50', '30', '10']),
CALL("var_cr_qin", ['50', '500', '15', '10']),
CALL("var_cr_qin", ['100', '50', '30', '10']),
CALL("var_cr_qin", ['100', '500', '15', '10']),
DEFINE("var_cr_qin",
	[['cr', 'Value'], ['qin', 'Value'], ['duration', 'Value'], ['intv', 'Value']],
	steps=(''])
		SETCONTROL("Qin","qin","float"),
		SETCONTROL("CO2_r","cr","float"),
		LOOP(dur="duration",
			units="Minutes",
			steps=()
				WAIT(dur="intv",units="Seconds"),
				LOG(),
			)
		),
	)
)
```
---
class: animated, fadeIn

# 关键步骤解释

### - DEFINE 是定义一个 subroutine，实际上是一个函数，我们此处定义了控光、控二氧化碳、控测量间隔和时长 4 个参数。注意，DEFINE 的位置不影响程序

### - CALL 是调用函数，分别输入不同的上述 4 个参数，做对应的控制测量

### - WAIT 除了等待时间外，还可以用于等待分析器读数稳定
---
class: animated, fadeIn, center, middle, inverse

# .large[示例5的演示]
---
class: inverse, center, middle, animated, fadeIn

# .large[谢谢！]

![](./img/gif-qrcode.gif)&lt;!-- --&gt;
## 关注公众号后获取更多精彩内容
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"ratio": "16:9",
"highlightStyle": "ir-black",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
